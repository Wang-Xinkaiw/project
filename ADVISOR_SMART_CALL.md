# 千问API智能调用功能说明

## 功能概述

本系统实现了智能调用千问API的功能，当系统连续50次（可配置）未检测到有效更改时，自动触发对千问API的调用，以获取具有指导性的改进意见。

## 核心特性

### 1. 智能触发机制
- **连续无改进检测**：系统持续监控策略性能改进情况
- **阈值触发**：当连续无改进轮次达到配置的阈值（默认50轮）时，自动调用千问API
- **性能改进判断**：只有当性能改进比例超过最小阈值（默认1%）时，才被视为有效改进

### 2. 灵活的参数配置
所有关键参数都可通过配置文件灵活调整：

```yaml
advisor:
  # 基础配置
  enabled: true  # 是否启用指导者
  api_key: "your_qwen_api_key_here"
  model: "qwen3-235b-a22b"
  
  # 智能调用配置
  smart_call_enabled: true  # 是否启用智能调用模式
  no_improvement_threshold: 50  # 连续无改进的轮次阈值
  min_performance_change: 0.01  # 判断为"有效改进"的最小性能变化比例（1%）
  call_history_enabled: true  # 是否保存调用历史记录
  call_history_file: "advisor_call_history.json"  # 调用历史记录文件路径
```

### 3. 完整的调用历史记录
系统会自动记录每次千问API调用的详细信息：
- 调用时间戳
- 调用原因
- 调用耗时
- 连续无改进轮次
- 当前最佳性能
- 指导建议摘要

调用历史会保存到JSON文件中，便于后续分析。

### 4. 详细的日志输出
系统会在日志中记录关键信息：
- 触发调用的原因和时机
- 调用过程中的状态
- 调用结果和耗时
- 连续无改进计数器的状态

## 工作流程

### 1. 性能监控
每轮迭代后，系统会：
- 计算当前策略的性能（平均迭代次数）
- 与历史最佳性能比较
- 判断是否为有效改进（改进比例 >= min_performance_change）

### 2. 连续无改进计数
- **有效改进**：重置连续无改进计数器为0
- **无效改进或性能变差**：连续无改进计数器+1

### 3. 触发判断
每轮迭代后，系统检查：
```python
if consecutive_no_improvement >= no_improvement_threshold:
    触发千问API调用
```

### 4. API调用
触发调用时，系统会：
- 记录调用开始时间
- 调用千问API获取指导建议
- 记录调用结束时间
- 保存调用历史
- 将指导建议整合到下一轮的策略生成中

### 5. 历史记录保存
每次调用后，系统会：
- 更新内存中的调用历史列表
- 保存到JSON文件（如果启用）
- 在最终结果中包含调用统计信息

## 配置参数详解

### smart_call_enabled
- **类型**：布尔值
- **默认值**：true
- **说明**：是否启用智能调用模式
  - true：只在达到阈值时调用
  - false：每轮都调用（与原行为一致）

### no_improvement_threshold
- **类型**：整数
- **默认值**：50
- **说明**：连续无改进的轮次阈值
  - 当连续无改进轮次达到此值时，触发千问API调用
  - 可以根据实际情况调整，建议范围：20-100

### min_performance_change
- **类型**：浮点数
- **默认值**：0.01（1%）
- **说明**：判断为"有效改进"的最小性能变化比例
  - 性能改进比例 >= 此值时，视为有效改进，重置计数器
  - 性能改进比例 < 此值时，仍视为无效改进，计数器+1
  - 可以根据实际情况调整，建议范围：0.005-0.02（0.5%-2%）

### call_history_enabled
- **类型**：布尔值
- **默认值**：true
- **说明**：是否保存调用历史记录
  - true：保存调用历史到JSON文件
  - false：不保存到文件，但仍在内存中记录

### call_history_file
- **类型**：字符串
- **默认值**："advisor_call_history.json"
- **说明**：调用历史记录文件的路径
  - 相对于项目根目录
  - 文件格式为JSON

## 调用历史记录格式

每次调用会生成如下记录：

```json
{
  "call_history": [
    {
      "iteration": 51,
      "timestamp": "2026-01-31 12:34:56",
      "reason": "连续无改进达到阈值(50轮)",
      "duration_seconds": 15.23,
      "consecutive_no_improvement": 50,
      "best_performance": 123.45,
      "guidance_summary": "## 整体诊断\n7个问题的整体收敛情况..."
    }
  ],
  "total_calls": 1,
  "last_updated": "2026-01-31 12:34:56"
}
```

## 日志示例

系统会输出如下日志信息：

```
2026-01-31 12:34:56 - INFO - 发现新最佳策略，性能: 123.45 (改进 0.50%，未达到显著改进阈值)
2026-01-31 12:35:10 - INFO - 第 51 轮迭代完成，平均性能: 123.45
2026-01-31 12:35:10 - INFO - 连续无改进次数(50)达到阈值(50)，触发千问指导者分析
2026-01-31 12:35:10 - INFO - 触发千问指导者分析 (连续无改进: 50/50)
2026-01-31 12:35:11 - INFO - 调用千问API (尝试 1/3)...
2026-01-31 12:35:25 - INFO - 千问API调用成功
2026-01-31 12:35:25 - INFO - 千问指导者分析完成
2026-01-31 12:35:25 - INFO - 千问API调用历史已保存到: advisor_call_history.json
```

## 优势与价值

### 1. 节省API调用成本
- 只在真正需要时调用，避免不必要的API调用
- 显著降低API调用次数和成本

### 2. 提高系统效率
- 减少等待API响应的时间
- 加快整体迭代速度

### 3. 提供有针对性的建议
- 在性能停滞时提供专家级分析
- 帮助突破优化瓶颈

### 4. 完整的可追溯性
- 详细的调用历史记录
- 便于后续分析和优化

### 5. 灵活的配置
- 所有参数可配置
- 适应不同的应用场景

## 使用建议

### 1. 参数调优
- **no_improvement_threshold**：
  - 初期可以设置较小值（如20-30），更频繁地获取建议
  - 后期可以设置较大值（如50-100），减少API调用

- **min_performance_change**：
  - 根据问题的难度调整
  - 简单问题可以设置较小值（如0.005）
  - 复杂问题可以设置较大值（如0.02）

### 2. 监控调用历史
- 定期查看调用历史文件
- 分析调用时机和效果
- 根据实际情况调整参数

### 3. 结合其他机制
- 可以与早停机制配合使用
- 在连续无改进达到阈值时，先调用千问API
- 如果仍无改进，再触发早停

## 注意事项

1. **API密钥安全**：
   - 不要将真实的API密钥提交到版本控制系统
   - 使用config.yaml.example作为模板
   - 将config.yaml添加到.gitignore

2. **网络连接**：
   - 确保网络连接稳定
   - 系统已实现重试机制（最多3次）

3. **调用频率限制**：
   - 注意API的调用频率限制
   - 避免短时间内大量调用

4. **性能监控**：
   - 定期查看日志和调用历史
   - 根据实际情况调整参数

## 未来扩展

可以考虑的扩展功能：
1. **自适应阈值**：根据历史性能自动调整阈值
2. **多级触发**：设置多个阈值，提供不同级别的建议
3. **预测性调用**：基于性能趋势预测何时需要调用
4. **成本优化**：根据API调用成本优化调用策略
5. **效果评估**：评估千问建议的实际效果，反馈到调用策略中

## 总结

智能调用千问API功能通过监控性能改进情况，在合适的时机触发专家级分析，既节省了API调用成本，又提供了有针对性的改进建议。该功能具有高度的灵活性和可配置性，能够适应不同的应用场景，为进化调参过程提供了强有力的支持。
